# Starling Controller Generator

This repository contains a number of template repositories for building up your own custom Starling compatible controller. This is designed in a modular way which allows you to mix and match different elements as you need. 

The idea is that a base Starling project is generated, but it contains no ROS nodes. Then you add whatever cpp/python or message custom ros packages afterwards. 

## Prerequisits

### Install cookiecutter
The template generation uses the [`cookiecutter`](https://cookiecutter.readthedocs.io/en/stable/README.html) tool for generating custom projects from a template. 

Then run:
```sh
python3 -m pip install --user cookiecutter
# or 
easy_install --user cookiecutter
```
> See [cookiecutter installation](https://cookiecutter.readthedocs.io/en/stable/installation.html) for further details on different platforms. 

This will give you access to the `cookiecutter` command line interface. 

### Install Starling Dependencies

Other than that you will need the prerequisits for Starling

### Sign up for Docker Hub and Github

Both are optional but suggested to make the most of the system. 

## Constructing your controller

### Generating the base Starling Project

The first step is to build your own Starling project. The following will start the process of using the template to generate a staring project. In your workspace, run the following command. 

```bash
cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory starling_template
```

It will follow by asking you to fill in a number of details. The value in the square brackets indicates the default value if you choose not to enter anything. Press Enter to go on to the next one. The inputs include
- Full Name - Your name
- Project Name - The name you have given to this Starling Project
- Github Username - Optionally your github username for filling in the README and metadata
- Docker Username - Optionally your docker hub username which is used for naming the Starling image. Will be used to upload to if you wish to push it online.
- Docker Image Name - The name of the Starling image that this repository produces
- Docker Image Name Full - An autogenerated name based on your username and image name, you can leave as the default unless you really want to change it.

Once complete, the project will be generated into a folder named by your `project_name`. For example, the default project with name `starling_controller` produces a project with the following structure:
```
starling_controller
|-- buildtools
    |-- docker-bake.hcl
|-- deployment
    |-- docker-compose.yml
    |-- kubernetes.yaml
|-- starling_controller
    |-- run.sh
|-- Dockerfile
|-- LICENSE
|-- Makefile
|-- README.md
```

We have the following folders and files.

- *starling_controller* will be populated by user created ros packages. Anything in this folder is directly  copied to the Dockerfile and built.
- *deployment* contains a sample docker-compose file which runs a default simulation stack, and a sample kubernetes file for deployment, both will most definitely need to be edited.
- *buildtools* contains the specification that docker uses to build the container. It contains the naming for the docker image. 
- *Dockerfile* contains the dockerfile which specifies the build steps for this project. It already specifies the installation of a number of dependencies, including [libInterpolate](https://github.com/CD3/libInterpolate) interpolation library. 

Once generated, the *Makefile* can be used to build and run commands:
```sh
make # Will build the project
make run # Will build and run the container
make run_bash # Will build and run the container, putting you in a bash shell inside it.
make help # Shows the help screen
```

This should successfuly build your project container which you can try and run or inspect. Currently it has no funcionality so nothing can happen. Have a look inside the container using `make run_bash`. 

> *Note* On windows you can either use WSL or have a look at some of the solutions [in this link](https://stackoverflow.com/questions/2532234/how-to-run-a-makefile-in-windows)

### Adding Nodes to your project

The generated project has no functionality right now. This repository contains other templates which will generate rosnodes for you. In particular

- *cpp_ros2_node_onboard_template*: Generates a ROS2 node, designed for running onboard the vehicle written in CPP.
- *python_ros2_node_offboard_template*: Generates a ROS2 node, designed for running offboard (central server) written in Python
- *ros2_msgs_template*: Generates a ROS2 msgs package which can be used by any ROS2 package within this container. 

These nodes can be added to your project using the following cookiecutter commands. Note that the packages should be generated into the `starling_project_name` directory of the base Starling project. Each of these commands are single line commands. 
```sh
# CPP Onboard
cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory cpp_ros2_node_onboard_template -o starling_controller/starling_controller
```

```sh
# Python Offboard
cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory python_ros2_node_offboard_template -o starling_controller/starling_controller
```

```sh
# Messages 
cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory ros2_msgs_template -o starling_controller/starling_controller
```

Similar to the generating of the base project, these will ask a number of questions to you during the generation. In particular it will ask what the `package_name` is which will become the name of that particular node package.

> *Note* convention for msg packages is to have a package name of format `<mymessages>_msgs`, e.g. `circle_experiment_msgs`. 

> *Note* For those familiar with ROS1, it is ROS2 convention to keep messages in a seperate package to the ros nodes themselves. 

> *Note* See below for the default example functionality that these template provide. 

These commands can be run standalone, one at a time, or whenever you need a new node within your project. 

Once these packages have been placed within the correct directory inside the Starling project, you can simply run `make` to check that they are successfully built. 

## Default Example Template Functionality
